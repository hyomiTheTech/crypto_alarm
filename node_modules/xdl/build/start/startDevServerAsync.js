"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startDevServerAsync = void 0;
const dev_server_1 = require("@expo/dev-server");
const internal_1 = require("../internal");
async function startDevServerAsync(projectRoot, startOptions) {
    internal_1.assertValidProjectRoot(projectRoot);
    let port;
    if (startOptions.metroPort != null) {
        // If the manually defined port is busy then an error should be thrown
        port = startOptions.metroPort;
    }
    else {
        port = startOptions.devClient
            ? Number(process.env.RCT_METRO_PORT) || 8081
            : await internal_1.getFreePortAsync(19000);
    }
    await internal_1.ProjectSettings.setPackagerInfoAsync(projectRoot, {
        expoServerPort: port,
        packagerPort: port,
    });
    const options = {
        port,
        logger: internal_1.ProjectUtils.getLogger(projectRoot),
        // @deprecated
        target: startOptions.target,
    };
    if (startOptions.reset) {
        options.resetCache = true;
    }
    if (startOptions.maxWorkers != null) {
        options.maxWorkers = startOptions.maxWorkers;
    }
    const { server, middleware, messageSocket } = await dev_server_1.runMetroDevServerAsync(projectRoot, options);
    middleware.use(internal_1.ManifestHandler.getManifestHandler(projectRoot));
    // We need the manifest handler to be the first middleware to run so our
    // routes take precedence over static files. For example, the manifest is
    // served from '/' and if the user has an index.html file in their project
    // then the manifest handler will never run, the static middleware will run
    // and serve index.html instead of the manifest.
    // https://github.com/expo/expo/issues/13114
    middleware.stack.unshift(middleware.stack.pop());
    return [server, middleware, messageSocket];
}
exports.startDevServerAsync = startDevServerAsync;
//# sourceMappingURL=startDevServerAsync.js.map