{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { Platform, UnavailabilityError } from '@unimodules/core';\nimport * as TaskManager from 'expo-task-manager';\nimport { BackgroundFetchResult, BackgroundFetchStatus } from \"./BackgroundFetch.types\";\nimport ExpoBackgroundFetch from \"./ExpoBackgroundFetch\";\nexport function getStatusAsync() {\n  return _regeneratorRuntime.async(function getStatusAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (!(Platform.OS === 'android')) {\n            _context.next = 2;\n            break;\n          }\n\n          return _context.abrupt(\"return\", BackgroundFetchStatus.Available);\n\n        case 2:\n          return _context.abrupt(\"return\", ExpoBackgroundFetch.getStatusAsync());\n\n        case 3:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function setMinimumIntervalAsync(minimumInterval) {\n  return _regeneratorRuntime.async(function setMinimumIntervalAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          if (ExpoBackgroundFetch.setMinimumIntervalAsync) {\n            _context2.next = 2;\n            break;\n          }\n\n          return _context2.abrupt(\"return\");\n\n        case 2:\n          _context2.next = 4;\n          return _regeneratorRuntime.awrap(ExpoBackgroundFetch.setMinimumIntervalAsync(minimumInterval));\n\n        case 4:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function registerTaskAsync(taskName) {\n  var options,\n      _args3 = arguments;\n  return _regeneratorRuntime.async(function registerTaskAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          options = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n\n          if (ExpoBackgroundFetch.registerTaskAsync) {\n            _context3.next = 3;\n            break;\n          }\n\n          throw new UnavailabilityError('BackgroundFetch', 'registerTaskAsync');\n\n        case 3:\n          if (TaskManager.isTaskDefined(taskName)) {\n            _context3.next = 5;\n            break;\n          }\n\n          throw new Error(\"Task '\" + taskName + \"' is not defined. You must define a task using TaskManager.defineTask before registering.\");\n\n        case 5:\n          _context3.next = 7;\n          return _regeneratorRuntime.awrap(ExpoBackgroundFetch.registerTaskAsync(taskName, options));\n\n        case 7:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function unregisterTaskAsync(taskName) {\n  return _regeneratorRuntime.async(function unregisterTaskAsync$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          if (ExpoBackgroundFetch.unregisterTaskAsync) {\n            _context4.next = 2;\n            break;\n          }\n\n          throw new UnavailabilityError('BackgroundFetch', 'unregisterTaskAsync');\n\n        case 2:\n          _context4.next = 4;\n          return _regeneratorRuntime.awrap(ExpoBackgroundFetch.unregisterTaskAsync(taskName));\n\n        case 4:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport { BackgroundFetchResult as Result, BackgroundFetchStatus as Status };","map":{"version":3,"sources":["../src/BackgroundFetch.ts"],"names":[],"mappings":";AAAA,SAAS,QAAT,EAAmB,mBAAnB,QAA8C,kBAA9C;AACA,OAAO,KAAK,WAAZ,MAA6B,mBAA7B;AAEA,SAEE,qBAFF,EAGE,qBAHF;AAKA,OAAO,mBAAP;AAEA,OAAO,SAAe,cAAf;AAAA;AAAA;AAAA;AAAA;AAAA,gBACD,QAAQ,CAAC,EAAT,KAAgB,SADf;AAAA;AAAA;AAAA;;AAAA,2CAEI,qBAAqB,CAAC,SAF1B;;AAAA;AAAA,2CAIE,mBAAmB,CAAC,cAApB,EAJF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOP,OAAO,SAAe,uBAAf,CAAuC,eAAvC;AAAA;AAAA;AAAA;AAAA;AAAA,cACA,mBAAmB,CAAC,uBADpB;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA,2CAKC,mBAAmB,CAAC,uBAApB,CAA4C,eAA5C,CALD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQP,OAAO,SAAe,iBAAf,CACL,QADK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEL,UAAA,OAFK,8DAE6B,EAF7B;;AAAA,cAIA,mBAAmB,CAAC,iBAJpB;AAAA;AAAA;AAAA;;AAAA,gBAKG,IAAI,mBAAJ,CAAwB,iBAAxB,EAA2C,mBAA3C,CALH;;AAAA;AAAA,cAOA,WAAW,CAAC,aAAZ,CAA0B,QAA1B,CAPA;AAAA;AAAA;AAAA;;AAAA,gBAQG,IAAI,KAAJ,YACK,QADL,+FARH;;AAAA;AAAA;AAAA,2CAYC,mBAAmB,CAAC,iBAApB,CAAsC,QAAtC,EAAgD,OAAhD,CAZD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeP,OAAO,SAAe,mBAAf,CAAmC,QAAnC;AAAA;AAAA;AAAA;AAAA;AAAA,cACA,mBAAmB,CAAC,mBADpB;AAAA;AAAA;AAAA;;AAAA,gBAEG,IAAI,mBAAJ,CAAwB,iBAAxB,EAA2C,qBAA3C,CAFH;;AAAA;AAAA;AAAA,2CAIC,mBAAmB,CAAC,mBAApB,CAAwC,QAAxC,CAJD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOP,SAAS,qBAAqB,IAAI,MAAlC,EAA0C,qBAAqB,IAAI,MAAnE","sourcesContent":["import { Platform, UnavailabilityError } from '@unimodules/core';\nimport * as TaskManager from 'expo-task-manager';\n\nimport {\n  BackgroundFetchOptions,\n  BackgroundFetchResult,\n  BackgroundFetchStatus,\n} from './BackgroundFetch.types';\nimport ExpoBackgroundFetch from './ExpoBackgroundFetch';\n\nexport async function getStatusAsync(): Promise<BackgroundFetchStatus | null> {\n  if (Platform.OS === 'android') {\n    return BackgroundFetchStatus.Available;\n  }\n  return ExpoBackgroundFetch.getStatusAsync();\n}\n\nexport async function setMinimumIntervalAsync(minimumInterval: number): Promise<void> {\n  if (!ExpoBackgroundFetch.setMinimumIntervalAsync) {\n    return;\n  }\n  // iOS only\n  await ExpoBackgroundFetch.setMinimumIntervalAsync(minimumInterval);\n}\n\nexport async function registerTaskAsync(\n  taskName: string,\n  options: BackgroundFetchOptions = {}\n): Promise<void> {\n  if (!ExpoBackgroundFetch.registerTaskAsync) {\n    throw new UnavailabilityError('BackgroundFetch', 'registerTaskAsync');\n  }\n  if (!TaskManager.isTaskDefined(taskName)) {\n    throw new Error(\n      `Task '${taskName}' is not defined. You must define a task using TaskManager.defineTask before registering.`\n    );\n  }\n  await ExpoBackgroundFetch.registerTaskAsync(taskName, options);\n}\n\nexport async function unregisterTaskAsync(taskName: string): Promise<void> {\n  if (!ExpoBackgroundFetch.unregisterTaskAsync) {\n    throw new UnavailabilityError('BackgroundFetch', 'unregisterTaskAsync');\n  }\n  await ExpoBackgroundFetch.unregisterTaskAsync(taskName);\n}\n\nexport { BackgroundFetchResult as Result, BackgroundFetchStatus as Status };\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}